<?xml version="1.0" encoding="UTF-8"?>
<reverse_engineering_knowledge_base>
    <vulnerability_type name="Static Analysis">
        <common_patterns>
            <pattern>String analysis: Hardcoded keys, flags, URLs</pattern>
            <pattern>Function identification: main, check_password, decrypt</pattern>
            <pattern>Control flow: Conditional jumps, loops, function calls</pattern>
            <pattern>Data sections: .data, .rodata, .bss segments</pattern>
            <pattern>Import analysis: Library functions, system calls</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Identify file type and architecture (x86, x64, ARM)</step>
            <step>2. Extract strings and analyze for clues</step>
            <step>3. Disassemble and identify main function</step>
            <step>4. Map control flow and key functions</step>
            <step>5. Look for hardcoded values and algorithms</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="file_info">file binary_name</payload>
            <payload type="strings_extract">strings binary_name | grep -i flag</payload>
            <payload type="readelf_headers">readelf -h binary_name</payload>
            <payload type="objdump_disasm">objdump -d binary_name</payload>
            <payload type="nm_symbols">nm binary_name</payload>
            <payload type="hexdump_data">hexdump -C binary_name | head -50</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>ELF header: 7f 45 4c 46</pattern>
            <pattern>PE header: 4d 5a (MZ)</pattern>
            <pattern>Mach-O header: fe ed fa ce</pattern>
            <pattern>String patterns: flag{, password, key</pattern>
        </detection_patterns>
    </vulnerability_type>

    <vulnerability_type name="Dynamic Analysis">
        <common_patterns>
            <pattern>Runtime behavior: Input validation, output generation</pattern>
            <pattern>Memory layout: Stack, heap, buffer locations</pattern>
            <pattern>System calls: File I/O, network, process creation</pattern>
            <pattern>Debugging: Breakpoints, memory inspection</pattern>
            <pattern>Tracing: Function calls, library usage</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Run binary with various inputs</step>
            <step>2. Attach debugger and set breakpoints</step>
            <step>3. Trace execution flow</step>
            <step>4. Monitor system calls and library functions</step>
            <step>5. Analyze memory contents at runtime</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="gdb_debug">gdb ./binary_name</payload>
            <payload type="strace_calls">strace ./binary_name</payload>
            <payload type="ltrace_libs">ltrace ./binary_name</payload>
            <payload type="valgrind_mem">valgrind --tool=memcheck ./binary_name</payload>
            <payload type="breakpoint">break main; run; info registers</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>Anti-debugging: ptrace detection, timing checks</pattern>
            <pattern>Packing: UPX, custom packers</pattern>
            <pattern>Obfuscation: Control flow flattening</pattern>
            <pattern>Encryption: Runtime decryption routines</pattern>
        </detection_patterns>
    </vulnerability_type>

    <vulnerability_type name="Buffer Overflow">
        <common_patterns>
            <pattern>Stack overflow: Return address overwrite</pattern>
            <pattern>Heap overflow: Chunk metadata corruption</pattern>
            <pattern>Format string: Printf family vulnerabilities</pattern>
            <pattern>Integer overflow: Arithmetic wrap-around</pattern>
            <pattern>Off-by-one: Boundary condition errors</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Identify vulnerable input functions (gets, strcpy)</step>
            <step>2. Determine buffer size and overflow offset</step>
            <step>3. Check for stack protections (canaries, NX, ASLR)</step>
            <step>4. Craft payload to control execution flow</step>
            <step>5. Execute shellcode or ROP chain</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="pattern_create">pattern_create.rb -l 200</payload>
            <payload type="pattern_offset">pattern_offset.rb -q 0x41414141</payload>
            <payload type="ret_overwrite">python -c "print 'A' * 140 + 'BBBB'"</payload>
            <payload type="shellcode">"\x31\xc0\x50\x68\x2f\x2f\x73\x68..."</payload>
            <payload type="rop_gadget">ROPgadget --binary binary_name</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>Vulnerable functions: gets, strcpy, sprintf</pattern>
            <pattern>Stack canaries: __stack_chk_fail</pattern>
            <pattern>NX bit: Executable stack disabled</pattern>
            <pattern>ASLR: Address randomization</pattern>
        </detection_patterns>
    </vulnerability_type>

    <vulnerability_type name="Cryptographic Implementations">
        <common_patterns>
            <pattern>Weak random numbers: Predictable keys</pattern>
            <pattern>Custom crypto: Flawed algorithms</pattern>
            <pattern>Key reuse: Same key for multiple operations</pattern>
            <pattern>Side channels: Timing, power analysis</pattern>
            <pattern>Implementation bugs: Off-by-one in crypto loops</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Identify cryptographic functions and algorithms</step>
            <step>2. Extract keys, IVs, and other parameters</step>
            <step>3. Analyze algorithm implementation for flaws</step>
            <step>4. Look for weak random number generation</step>
            <step>5. Test known attack vectors</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="key_extraction">grep -r "key\|password\|secret" .</payload>
            <payload type="entropy_test">ent data_file</payload>
            <payload type="xor_analysis">xortool encrypted_data</payload>
            <payload type="frequency">python -c "from collections import Counter; print(Counter(open('file','rb').read()))"</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>Crypto constants: AES S-box, DES permutations</pattern>
            <pattern>Algorithm patterns: XOR loops, rotation operations</pattern>
            <pattern>Library usage: OpenSSL, libcrypto functions</pattern>
            <pattern>Key schedules: AES key expansion</pattern>
        </detection_patterns>
    </vulnerability_type>

    <vulnerability_type name="Obfuscation and Packing">
        <common_patterns>
            <pattern>Code packing: UPX, ASPack, custom packers</pattern>
            <pattern>Control flow obfuscation: Indirect jumps, spaghetti code</pattern>
            <pattern>String obfuscation: XOR encoding, base64</pattern>
            <pattern>Anti-analysis: Debugger detection, VM detection</pattern>
            <pattern>Dynamic loading: Runtime code generation</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Detect packing using entropy analysis</step>
            <step>2. Unpack using automated tools or manual methods</step>
            <step>3. Bypass anti-analysis techniques</step>
            <step>4. Deobfuscate control flow and strings</step>
            <step>5. Analyze unpacked/deobfuscated code</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="upx_unpack">upx -d packed_binary</payload>
            <payload type="entropy_check">ent binary_file</payload>
            <payload type="dump_memory">gdb -ex "dump memory unpacked.bin 0x400000 0x500000"</payload>
            <payload type="string_decode">python decode_strings.py obfuscated_binary</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>High entropy sections: Packed/encrypted code</pattern>
            <pattern>Minimal imports: Packed binaries</pattern>
            <pattern>Anti-debug: IsDebuggerPresent, ptrace</pattern>
            <pattern>VM detection: CPUID checks, timing</pattern>
        </detection_patterns>
    </vulnerability_type>

    <vulnerability_type name="Format String Vulnerabilities">
        <common_patterns>
            <pattern>User input as format string: printf(user_input)</pattern>
            <pattern>Stack reading: %x %p format specifiers</pattern>
            <pattern>Arbitrary write: %n format specifier</pattern>
            <pattern>GOT overwrite: Global Offset Table modification</pattern>
            <pattern>Return address modification: Stack manipulation</pattern>
        </common_patterns>
        <exploitation_guide>
            <step>1. Identify printf-family functions with user input</step>
            <step>2. Test format string injection with %x %s %n</step>
            <step>3. Map stack layout using format specifiers</step>
            <step>4. Craft payload to read/write arbitrary memory</step>
            <step>5. Overwrite function pointers or return addresses</step>
        </exploitation_guide>
        <example_payloads>
            <payload type="stack_read">%x.%x.%x.%x.%x.%x</payload>
            <payload type="string_read">%s</payload>
            <payload type="arbitrary_write">%n</payload>
            <payload type="got_overwrite">python -c "print('\x12\x34\x56\x78' + '%12345c%4$n')"</payload>
            <payload type="parameter_access">%4$x</payload>
        </example_payloads>
        <detection_patterns>
            <pattern>printf, sprintf, fprintf with user input</pattern>
            <pattern>Format string not literal constant</pattern>
            <pattern>Missing format string protections</pattern>
            <pattern>Writable GOT section</pattern>
        </detection_patterns>
    </vulnerability_type>

    <tools_and_techniques>
        <tool name="Ghidra">
            <description>NSA's reverse engineering framework</description>
            <use_cases>Disassembly, decompilation, analysis</use_cases>
        </tool>
        <tool name="IDA Pro">
            <description>Interactive disassembler</description>
            <use_cases>Static analysis, debugging, scripting</use_cases>
        </tool>
        <tool name="radare2">
            <description>Reverse engineering framework</description>
            <use_cases>Disassembly, debugging, binary analysis</use_cases>
        </tool>
        <tool name="GDB">
            <description>GNU debugger</description>
            <use_cases>Dynamic analysis, debugging, memory inspection</use_cases>
        </tool>
        <tool name="Frida">
            <description>Dynamic instrumentation toolkit</description>
            <use_cases>Runtime analysis, hooking, mobile apps</use_cases>
        </tool>
        <tool name="Binary Ninja">
            <description>Reverse engineering platform</description>
            <use_cases>Disassembly, intermediate language, analysis</use_cases>
        </tool>
        <tool name="x64dbg">
            <description>Windows debugger</description>
            <use_cases>Windows binary analysis, debugging</use_cases>
        </tool>
        <tool name="Volatility">
            <description>Memory forensics framework</description>
            <use_cases>Memory dump analysis, malware analysis</use_cases>
        </tool>
    </tools_and_techniques>

    <common_ctf_patterns>
        <pattern name="Hidden Strings">
            <description>Encoded or encrypted strings in binary</description>
            <solution>XOR decoding, base64, custom encoding</solution>
        </pattern>
        <pattern name="Input Validation">
            <description>Specific input required for flag</description>
            <solution>Reverse algorithm, brute force validation</solution>
        </pattern>
        <pattern name="Algorithm Reversal">
            <description>Custom algorithm needs to be reversed</description>
            <solution>Trace execution, understand logic, implement inverse</solution>
        </pattern>
        <pattern name="Patching Required">
            <description>Binary modification needed</description>
            <solution>NOP instructions, change jumps, modify checks</solution>
        </pattern>
        <pattern name="Serial Key Validation">
            <description>License key or serial validation</description>
            <solution>Reverse validation algorithm, generate valid key</solution>
        </pattern>
        <pattern name="Anti-Debugging">
            <description>Debugger detection and evasion</description>
            <solution>Patch checks, use stealthy debugging</solution>
        </pattern>
    </common_ctf_patterns>

    <assembly_patterns>
        <x86_patterns>
            <mov>Data movement: mov eax, 0x12345678</mov>
            <cmp>Comparison: cmp eax, 0x0</cmp>
            <jmp>Unconditional jump: jmp 0x401000</jmp>
            <je>Conditional jump: je 0x401010</je>
            <call>Function call: call 0x401020</call>
            <ret>Return: ret</ret>
            <push>Stack push: push eax</push>
            <pop>Stack pop: pop ebx</pop>
        </x86_patterns>
        <x64_patterns>
            <mov>Data movement: mov rax, 0x123456789abcdef0</mov>
            <lea>Load effective address: lea rax, [rbx+rcx*2]</lea>
            <syscall>System call: syscall</syscall>
            <xor>XOR operation: xor rax, rax</xor>
        </x64_patterns>
        <arm_patterns>
            <mov>Data movement: mov r0, #0x12</mov>
            <ldr>Load register: ldr r1, [r2]</ldr>
            <str>Store register: str r0, [r1]</str>
            <b>Branch: b label</b>
            <bl>Branch with link: bl function</bl>
        </arm_patterns>
    </assembly_patterns>

    <debugging_techniques>
        <breakpoints>
            <hardware>Hardware breakpoints: limited but stealthy</hardware>
            <software>Software breakpoints: INT3 instruction</software>
            <conditional>Conditional breakpoints: break on condition</conditional>
        </breakpoints>
        <memory_analysis>
            <stack>Stack frame analysis: base pointer, local vars</stack>
            <heap>Heap analysis: malloc/free tracking</heap>
            <sections>Binary sections: .text, .data, .bss</sections>
        </memory_analysis>
        <anti_debugging>
            <detection>Debugger detection: IsDebuggerPresent</detection>
            <timing>Timing attacks: rdtsc instruction</timing>
            <exceptions>Exception handling: SEH, signal handlers</exceptions>
        </anti_debugging>
    </debugging_techniques>
</reverse_engineering_knowledge_base>